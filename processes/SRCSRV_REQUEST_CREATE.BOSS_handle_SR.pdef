# This process is part of the MINT standard process
#
# It should be linked to projects where BOSS should handle SRs.
# Also copy SRCSRV_REQUEST_CREATE.BOSS_handle_SR.conf to those
# projects, and modify it as needed.

# A request to the target project starts a process which handles the request.
# The request has a list of packages, a source and a target.

Ruote.process_definition 'BOSS_handle_SR' do
  sequence do

    ################################################################
    # Debugging

    # To enable debug dumps for *every* participant, uncomment this
    #set 'debug_dump' => 'TRUE'

    # Alternatively you may set the following parameter on individual
    # participants:
    #   :debug_dump => 'TRUE'
    # To enable BOSS process tracing:
    #set 'boss_trace' => 'TRUE'

    # set some initial values that are specific to the process
    # the initial status is set to SUCCESS and if it changes at any time
    # it is considered a failure.
    set 'status' => 'SUCCESS'
    set 'ver' => '0.1'

    # Simplify some conditionals later on
    set 'build_trial.create' => '', :if => '"${build_trial.create}" == "false"'
    set 'build_trial.remove_on_fail' => '', :if => '"${build_trial.remove_on_fail}" == "false"'
    set 'build_trial.remove_on_accept' => '', :if => '"${build_trial.remove_on_accept}" == "false"'

    ################################################################
    # Start the process

    # First the request is labelled 'in review' (ie it needs some OBS
    # work to complete) Then the process looks at all packages and
    # runs checks on each

    report_event :msg => 'Process started'
    change_request_state :if => 'auto_review in ${stages}',
                         :action => 'add review',
                         :comment => "Under automated review"

    # Fetch the package specific configuration data
    get_package_boss_conf

    _if :test => 'prechecks in ${stages}' do
      sequence do
        report_event :msg => 'Running checks'

        # Many checks require relevant changelog information in the WI
        get_relevant_changelog

        # Get ${targetrepo} if needed
        _if :test => 'check_package_built_at_source in ${prechecks}' do
          sequence do
            # Not using this for some reason
            #check_has_valid_repo
            # Fallback
            set 'targetrepo' => '${repository}'
          end
        end

        iterator :on_field => 'prechecks', :to => 'v:check' do
          sequence do
            _break :if => '"${v:check}" == ""'  # deal with the sentinel value
            echo 'running ${v:check}'
            given '${v:check}' do
              of 'check_valid_changes' do
                check_valid_changes :using => 'relevant_changelog'
              end
              # if no special cases match...
              participant '${v:check}'
            end
            _if :test => '${__result__} != true' do set 'status' => 'FAIL' end
          end
        end

        _if :test => '${status} != SUCCESS' do
          sequence do
            do_reject
            # It is safe to terminate here as we're not holding a lock
	        report_event :msg => 'Process finished'
            terminate
          end
        end

        change_request_state :if => 'auto_review in ${stages}',
                             :action => 'accept review',
                             :comment => "Prechecks completed; none failed."
      end
    end

    # Checkpoint A: ask for human review if configured to do so before getting a
    # lock and doing expensive tests
    do_review_before_lock :if => 'review_before_lock in ${stages}'

    # The next step is to simulate acceptance by doing a build of the
    # requested packages in the Testing project. We wait for a lock,
    # the request is then built and the process waits until a 'built'
    # action is run (elsewhere).  Once built, a subprocess is called
    # to run the QA/OTS checks and the request is then either accepted
    # or another subprocess is called to clean up the Testing area.

    with_OBS_ticket do
      cursor :break_if => '${f:status} != SUCCESS' do

        do_build_trial_subprocess :if => 'trial_build in ${stages}'

        do_build_image :if => 'build_image in ${stages}'

        do_test_image :if => 'build_image in ${stages} and test_image in ${stages}'

        #do_review_after_lock :if => 'review_after_lock in ${stages}'

      end

      _if '${f:status} != SUCCESS' do
        sequence do
          do_reject
          do_revert_trial_subprocess :if => 'trial_build in ${stages}', :state => "fail"
        end
        # _else
        sequence do
          do_accept
          do_report :if => 'report in ${stages}'
          do_revert_trial_subprocess :if => 'trial_build in ${stages}', :state => "success"
        end
      end

    end
    report_event :msg => 'Process finished'
  end

  ################################################################
  # This is the QA subprocess; the final step that determines if the
  # request is accepted' It creates a kickstart file, calls IMG and
  # then submits the image to OTS. If all is well then the process to
  # update the information system runs.

  define 'do_review_before_lock' do
    sequence do
      change_request_state :action => 'add review',
                           :user => '${f:reviewer}',
                           :comment => "Please replace this text with a review"+
                                       " and approve/reject the review (not "+
                                       " the SR). BOSS will take care of the"+
                                       " rest"

      # This blocks until the request state is changed. Helper proces that
      # triggers the request_notice participant on SRCSRV_REQUEST_STATECHANGE
      # is needed
      listen :to => 'req_changed_${ev.id}', :upon => 'reply',
             :where => '"${ev.state}" in ["new", "declined", "revoked", "accepted"]'

      # if reviewer declines or revokes this request we don't want to continue
      # declined also happens in case the review was rejected because of hardcoded OBS workflow
      _if :test => '${ev.state} == declined or ${ev.state} == revoked]' do
        sequence do
          report_event :msg => '${f:reviewer} rejected the review and the request. Process finished'
          do_notify_reject
          # It is safe to terminate here as we're not holding a lock
          terminate
        end
      end

      # if reviewer short circuits and accepts this request we don't want to continue
      _if :test => '${ev.state} == accepted' do
        sequence do
          report_event :msg => '${f:reviewer} accepted the request. Process finished.'
          do_notify_accept
          # It is safe to terminate here as we're not holding a lock
          terminate
        end
      end

      # if reviewer approves the review it goes back to new state
      _if :test => '${ev.state} == new' do
        sequence do
          report_event :msg => '${f:reviewer} approved the review'
        end
      end

    end
  end

  define 'do_build_image' do
    change_request_state :if => 'auto_review in ${stages}', 
                         :action => 'add review', 
                         :comment => "Image build trial under progress using ${f:build_trial.project}"

    report_event :msg => 'Check image'
    cursor :break_if => '${__result__} != true' do
      # FIXME : define image?
      # defineimage :image_type => 'testing'
      report_event :msg => 'Prepare a ks'
      build_ks
      request_image
      report_event :msg => 'Build image'
      build_image :debug_dump => 'true'
    end
    # Ugly hack. Errors return __result__ == false but don't set status==FAILED
    # This will be resolved when we handle __error__ better
    _if :test => '${__result__} != true' do
      sequence do
        set 'f:status' => 'FAILED'
        report_event :msg => 'Image build failed'
      end
      # _else
      sequence do
          change_request_state :if => 'auto_review in ${stages}',
                               :action => 'accept review',
                               :comment => "Image build trial successfully completed."
      end
    end
    report_event :msg => 'Check image done'
  end


  define 'do_test_image' do
    sequence do

      change_request_state :if => 'auto_review in ${stages}',
                           :action => 'add review',
                           :comment => "Image test under progress"
      #test_image
      report_event :msg => 'Would now test but OTS disabled'
      _if :test => '${__result__} != true' do
        sequence do
          set 'f:status' => 'FAILED'
          report_event :msg => 'Image test failed'
        end
        # _else
        sequence do
          change_request_state :if => 'auto_review in ${stages}',
                               :action => 'accept review',
                               :comment => "Image test passed."
        end
      end

    end
  end

  ################################################################
  # Any error causes the request to be rejected and the submitter
  # notified

  define 'do_reject' do
    sequence do

      report_event :msg => 'Rejecting'
      change_request_state :if => 'auto_review in ${stages}',
                           :action => 'accept review',
                           :comment => "Review completed. BOSS suggests rejecting the request."

      change_request_state :if => 'reject in ${stages}', :action => 'reject'
      set 'status' => 'FAILED'
      do_notify_reject

    end
  end

  define 'do_notify_reject' do
    sequence do

      # Get the request as it stands at the moment.
      get_request :req_id => "${ev.id}", :field => "req", :on_error => 'do_request_vanished'
      get_userdata :user => "${req.state.who}", :field => "author"
      get_notify_recipients_obs :role => 'submitter'
      notify :template => 'submit_request', :subject => '[BOSS] Rejected promotion request #${ev.id}'

    end
  end

  ################################################################
  # As packages move into Trunk, their bug & feature status need
  # updating and the reporting system is notified of progress.  The
  # final update steps are to accept the request and notify the user

  define 'do_accept' do
    sequence do

      report_event :msg => 'Accepting'
      change_request_state :if => 'auto_review in ${stages}',
                           :action => 'accept review',
                           :comment => "Review completed. All steps passed, BOSS suggests accepting the request."

      change_request_state :if => 'accept in ${stages}', :action => 'accept', :debug_dump => 'TRUE'

    end
  end

  define 'do_notify_accept' do
    sequence do

      get_request :req_id => "${ev.id}", :field => "req", :on_error => 'do_request_vanished'
      get_userdata :user => "${req.state.who}", :field => "author"
      get_notify_recipients_obs :role => 'submitter'
      get_notify_recipients_obs :role => 'target project maintainers', :cc => 't'
      notify :template => 'submit_request', :subject => '[BOSS] Accepted promotion request #${ev.id}'

    end
  end

  define 'do_report' do
    sequence do

      # Now for each package promoted, 
      iterator :on_field => 'ev.actions', :to_field => 'action' do
        sequence do
          set 'f:package' => '${action.sourcepackage}'
          #report_event :msg => 'Doing updates for ${package} after success'
          #getchangelog
          #bz
          feed_revs :if => 'revs in ${stages}'
        end
      end

      # Allow REVS to process the image
      revs_image :if => 'revs in ${stages} and build_image in ${stages}'
      do_notify_accept

    end
  end


  ################################################################
  # This utility subprocess wraps a group of actions inside other
  # process steps; in this case reserving the use of a build project

  define 'with_OBS_ticket' do
    sequence do
      report_event :msg => 'Waiting for trial area to be free'
      obsticket :action => 'get', :lock_project => '${project}'
      report_event :msg => 'Got trial area (locked)'
      apply
      report_event :msg => 'Unlocking trial area'
      obsticket :action => 'release', :lock_project => '${project}'
    end
  end

  define 'report_event' do
    sequence do
      echo 'SR#${ev.id} ${v:msg}'
      notify_irc :if => '"${irc_channel}" != ""',
                 :msg => 'SR#${ev.id} ${v:msg}',
                 :irc_channel => '${irc_channel}'
    end
  end

  define 'do_revert_trial_subprocess' do
    sequence do

      _if :test => '"${f:build_trial.create}" != ""' do
        sequence do
          remove_build_trial :if => '${v:state} == fail and "${f:build_trial.remove_on_fail}" != ""'
          remove_build_trial :if => '${v:state} == success and "${f:build_trial.remove_on_accept}" != ""'
        end
        # _else
        sequence do
          do_revert_trial :build_in => '${build_trial.project}', :linked => 'True'
        end
      end

    end
  end

  define 'do_build_trial_subprocess' do
    sequence do

      # Now create a per-SR trial_project if configured to do so
      # if the conf didn't initialize the project name under will be an empty
      # string and the participant will fallback to the same default behavior as
      # the next statement
      setup_build_trial :if => '"${f:build_trial.create}" != ""', :under => '${f:build_trial.project}'
      # or use a precreated one, by default project:Trial
      set "f:build_trial.project" => "${f:project}:Trial", :if => '"${f:build_trial.project" == ""}'

      change_request_state :if => 'auto_review in ${stages}',
                           :action => 'add review',
                           :comment => "Build trial under progress in ${f:build_trial.project}"

      report_event :msg => 'Start trial build : ${build_trial.project}'
      do_build_trial :build_in => '${build_trial.project}', :linked => 'True'

      # This now waits for a build to finish
      report_event :msg => 'Wait for trial build : ${build_trial.project}'
      repeat :timeout => '60m', :on_timeout => 'error' do
        report_event :msg => 'Is repo published?'
        is_repo_published :project => '${build_trial.project}'
        _break :if => '${f:__result__}'
        wait '30s'
      end

      report_event :msg => 'Build done : ${build_trial.project}'
      get_build_trial_results :build_in => '${build_trial.project}'

      _if :test => '${f:__result__} == false' do
        sequence do
          report_event :msg => 'Trial build failures : ${new_failures}'
          set 'status' => 'FAILED'
        end
        # _else
        sequence do
          report_event :msg => 'Trial build succeeded'
          change_request_state :if => 'auto_review in ${stages}',
                               :action => 'accept review',
                               :comment => "Build trial completed; nothing failed."
        end
      end

    end
  end

end
