# This process is part of the MINT standard process
#
# It should be linked to SRCSRV_REQUEST_CREATE in projects where BOSS should
# handle SRs
#
#
# A request to the target project starts a process which handles the request.
# The request has a list of packages, a source and a target.

Ruote.process_definition 'BOSS_handle_SR' do
  sequence do

# FIXME: Configuration should have a participant to do 'configure_standard_process'

# always recieves copies of emails
    set 'email' => ['david@dgreaves.com']
# The repository in target (Trunk) project (FIXME: should be automatic?)
    set 'repository' => 'standard'

# Architecture being considered for build-success comparison
    set 'archs' => ['i586']

# Type of image used for testing
    set 'targetrepo' => 'standard'
    set 'final_project' => 'Chalk:Trunk'
    set 'irc_channel' => '#meego-boss'

    set 'image' => {'image_type' => 'livecd',
                    'arch' => 'i586',
                    'name' => 'core-ia32-generic',
                    'ksfile' => 'core-ia32-generic.ks'
                    }


# The SR should be aimed at the ultimate target project.
# A trial build  and :Testing is appended to its name for the project to
# test in.  This should not need changing.
    # FIXME : this should include the SR# somehow
    # set 'trial_project' => '${project}:Testing:${rid}'
    set 'trial_project' => '${project}:Testing'


    ################################################################
    # Debugging
    # debug setting to skip actual testing (FIXME: is this correct?)
    #set 'debug' => 'TRUE'

    # To enable debug dumps for *every* participant, uncomment this
    #set 'debug_dump' => 'TRUE'

    # Alternatively you may set the following parameter on individual
    # participants:
    #   :debug_dump => 'TRUE'
    # To enable BOSS process tracing:
    #set 'boss_trace' => 'TRUE'

    # set some initial values that are specific to the process
    # the initial status is set to SUCCESS and if it changes at any time
    # it is considered a failure.
    set 'status' => 'SUCCESS'
    set 'pname' => 'BOSS_handle_SR'
    set 'ver' => '0.1'

################################################################
# Start the process

    # First the request is labelled 'in review' (ie it needs some OBS
    # work to complete) Then the process looks at all packages and
    # runs checks on each (stopping as soon as the first problem is
    # found).
    cursor :break_if => '${status} != SUCCESS' do
      echo "Begin checks for SR#${ev.id}"
      #notify_irc :msg => 'SR#${ev.id} TODO: Move to review state and then do checks', :irc_channel=> '${irc_channel}'
      #change_request_state :action => 'review', :txt => "Being reviewed by BOSS"
      #check_process
      #check_quality
      #check_policy
      echo "End checks for SR#${ev.id}"
    end

    do_reject :if => '${status} != SUCCESS'

    # The next step is to simulate acceptance by doing a build of the
    # requested packages in the Testing project. We wait for a lock,
    # the request is then built and the process waits until a 'built'
    # action is run (elsewhere).  Once built, a subprocess is called
    # to run the QA/OTS checks and the request is then either accepted
    # or another subprocess is called to clean up the Testing area.

    # FIXME : Locking not yet working
    with_OBS_ticket do
      sequence do
        echo 'SR#${ev.id} Start trial build : ${trial_project}'
        #notify_irc :msg => 'SR#${ev.id} Start trial build : ${trial_project}', :irc_channel=> '${irc_channel}'
        # Now create and monitor a per-SR trial_project
        #prepare_trial_build :build_in => '${trial_project}'
        #robogrator_monitor_build_project :monitor_project => '${trial_project}'
        do_build_trial :build_in => '${trial_project}', :linked => 'True'

        # This now waits for a build to finish
        echo 'SR#${ev.id} Wait for trial build : ${trial_project}'
        repeat :timeout => '30m', :on_timeout => 'error' do
          is_repo_published :project => '${trial_project}'
          _break :if => '${f:__result__}'
          wait '30s'
          echo 'Is repo published?'
        end
        echo 'SR#${ev.id} Build done : ${trial_project}'
	get_build_trial_results :build_in => '${trial_project}'

        _if :test => '${f:__result__} == false' do
          sequence do
            echo "Failures : ${new_failures}"
            do_reject
          end
        # _else
          sequence do
            do_check_image
            _if :test => '${f:status} != SUCCESS' do
              do_reject
              do_accept_and_update
            end
          end
        end
	# Do this after the image is built (and maybe not at all if it fails when
	# we're doing per-SR projects)
        do_revert_trial :build_in => '${trial_project}', :linked => 'True'
      end
    end
  end

  ################################################################
  # This is the QA subprocess; the final step that determines if the
  # request is accepted' It creates a kickstart file, calls IMG and
  # then submits the image to OTS. If all is well then the process to
  # update the information system runs.

  define 'do_check_image' do
    echo 'SR#${ev.id} check_image'
    cursor :break_if => '${status} != SUCCESS' do
      # FIXME : define image?
      # defineimage :image_type => 'testing'
      build_ks :from => 'selected_packages'
      build_image
      # Disable test_image until OTS is operational
      #test_image
    end
    echo 'SR#${ev.id} check_image done: ${status}'
  end

  ################################################################
  # Any error causes the request to be rejected and the submitter
  # notified

  define 'do_reject' do
    sequence do
      echo 'SR#${ev.id} do_reject'
      change_request_state :action => 'reject'
      set 'status' => 'FAILED'
      #notify :template => 'submit_request', :subject => '[BOSS] Rejected promotion request #${rid}', :extra_msg => '${build_msg}'
    end
  end

  ################################################################
  # As packages move into Trunk, their bug & feature status need
  # updating and the reporting system is notified of progress.  The
  # final update steps are to accept the request and notify the user

  define 'do_accept_and_update' do
    sequence do
      echo 'SR#${ev.id} do_accept_and_update'
      # FIXME: should the process verify with a human before approving (need a UI)
      # change_request_state :action => 'seek_approval'
      change_request_state :action => 'accept', :debug_dump => 'TRUE'

      # Now for each package promoted, 
      iterator :on_field => 'packages', :to_field => 'package' do
        sequence do
	  echo "Doing updates for ${package} after success"
	  #getchangelog
          #bz
          #revs_update
        end
      end
      #notify :template => 'submit_request', :subject => '[BOSS] Accepted promotion request #${rid}', :extra_msg => '${build_msg}'
    end
  end

  ################################################################
  # This utility subprocess wraps a group of actions inside other
  # process steps; in this case reserving the use of a build project

  define 'with_OBS_ticket' do
    sequence do
      echo 'Get Lock ${trial_project}'
      obsticket :action => 'get', :lock_project => '${trial_project}'
      echo 'Got Lock ${trial_project}'
      apply
      echo 'Unlock ${trial_project}'
      obsticket :action => 'release', :lock_project => '${trial_project}'
      echo 'Unlocked ${trial_project}'
    end
  end

end
